# Scheme 48 Makefile
# Documentation in files INSTALL and doc/install.txt

SHELL = /bin/sh

### Filled in by `configure' ###
srcdir = @srcdir@
VPATH = @srcdir@
CC = @CC@
DEFS = @DEFS@ -D__COMPILING_SCHEME48_ITSELF__
LIBS = @LIBS@
CFLAGS = @CFLAGS@
CPPFLAGS =
INSTALL = @INSTALL@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_DATA = @INSTALL_DATA@

LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@

GC_OBJS = @GC_OBJS@

prefix = @prefix@
exec_prefix = @exec_prefix@
### End of `configure' section###

bindir = $(exec_prefix)/bin
libdir = $(exec_prefix)/lib
incdir = $(exec_prefix)/include
manext = 1
mandir = $(prefix)/man/man$(manext)

# HP 9000 series, if you don't have gcc
#   CC = cc
#   CFLAGS = -Aa -O +Obb1800
#   DEFS = -D_HPUX_SOURCE -Dhpux

# Ultrix
#   LDFLAGS = -N

.c.o:
	$(CC) -c $(CPPFLAGS) $(DEFS) -I ./c -I$(srcdir)/c -I$(srcdir)/c/bibop $(CFLAGS) -o $@ $<

# You might want to change RUNNABLE to "s48"
RUNNABLE = scheme48
MANPAGE = $(RUNNABLE).$(manext)
LIB = $(libdir)/$(RUNNABLE)

distdir = /tmp

# If make barfs on this include line, just comment it out.  It's only
# really needed if you want to build the linker or rebuild initial.image.
include $(srcdir)/build/filenames.make
#
#NetBSD make wants to see this instead:
#.include "$(srcdir)/build/filenames.make"


# Static linker:
#
# You only need the linker if you're going to make changes to the
# things that go into the initial.image, which in general means the
# files in rts/.  If you decide you need to use the linker, then you
# gots your choice; it can run in just about any version of Scheme 48
# or Pseudoscheme.  (It has also been made to run in Scheme->C.)  It
# doesn't matter a whole lot which Scheme you use as long as it's not
# broken or unavailable.  The two best choices are:
# 1. As below.
#    These settings requires you to already have a $(RUNNABLE)
#    command.  This is desirable if you are making changes to the
#    system that might break scheme48vm and/or scheme48.image.  But it
#    requires you to have squirreled away a previous working version
#    of scheme48.
# 2. LINKER_VM = ./$(VM) $(BIG_HEAP)
#    LINKER_RUNNABLE = $(LINKER_VM) -i $(IMAGE)
#    This builds the linker on the scheme48vm and scheme48.image
#    that are in the current directory.

BIG_HEAP = -h 8000000
LINKER_VM = $(RUNNABLE) $(BIG_HEAP)
LINKER_RUNNABLE = $(LINKER_VM)
START_LINKER = echo ',batch';					\
	       echo ',bench on';				\
	       echo ',open signals handle features';		\
	       echo ',open bitwise ascii code-vectors';		\
	       echo ',open cells record-types';			\
	       echo ',load $(linker-files)';			\
	       echo ',load scheme/alt/init-defpackage.scm'

# --------------------
# You shouldn't have to change anything below this point, except for possibly
# the external code rules.

# Targets:

IMAGE = scheme48.image
INITIAL = $(srcdir)/build/initial.image
VM = scheme48vm
LIBSCHEME48 = c/libscheme48.a
UNIX_OBJS = c/unix/misc.o c/unix/io.o c/unix/fd-io.o c/unix/event.o
OBJS =	c/scheme48vm.o \
	c/extension.o c/free.o c/double_to_string.o \
	c/external.o c/bignum.o c/init.o

FAKEHS	= c/fake/dlfcn.h c/fake/sigact.h c/fake/strerror.h \
		c/fake/sys-select.h

SCHEME48HS = c/scheme48.h c/scheme48write-barrier.h

# Sources:

CONFIG_FILES = scheme/interfaces.scm scheme/packages.scm \
	       scheme/vm/shared-interfaces.scm	\
	       scheme/low-packages.scm scheme/rts-packages.scm \
	       scheme/comp-packages.scm scheme/initial-packages.scm

# Rules:

# The following is the first rule and therefore the "make" command's
# default target.
enough: vm $(LIBSCHEME48) $(IMAGE) script-interpreter go

# --------------------
# External code to include in the VM
# After changing any of these you should delete `scheme48vm' and remake it.

EXTERNAL_OBJECTS = $(POSIX_OBJECTS) $(SOCKET_OBJECTS) $(DYNLINK_OBJECTS) \
		   $(SYSEXITS_OBJECTS) $(LOOKUP_OBJECTS) $(ASM_OBJECTS) \
		   $(SRFI_OBJECTS)
EXTERNAL_LD_FLAGS = $(POSIX_LD_FLAGS) $(SOCKET_LD_FLAGS) $(DYNLINK_LD_FLAGS) \
		    $(SYSEXITS_LD_FLAGS)
EXTERNAL_INITIALIZERS = $(POSIX_INITIALIZERS) $(SOCKET_INITIALIZERS)	\
			$(DYNLINK_INITIALIZERS)				\
			$(SYSEXITS_INITIALIZERS)			\
                        $(LOOKUP_INITIALIZERS) $(ASM_INITIALIZERS)	\
			$(SRFI_INITIALIZERS)

# Rules for any external code.

# POSIX rules; this could have its own Makefile, but I don't want to bother.

posix_dir = c/posix

$(posix_dir)/user.o     $(posix_dir)/regexp.o	\
$(posix_dir)/proc-env.o $(posix_dir)/io.o:	\
	$(SCHEME48HS) c/c-mods.h $(posix_dir)/posix.h

$(posix_dir)/proc.o:	\
	$(SCHEME48HS) c/c-mods.h \
	c/event.h $(posix_dir)/posix.h $(posix_dir)/s48_signals.h

$(posix_dir)/dir.o:	\
  $(SCHEME48HS) c/scheme48heap.h c/c-mods.h \
  c/event.h c/fd-io.h $(posix_dir)/posix.h

POSIX_OBJECTS = $(posix_dir)/user.o     $(posix_dir)/regexp.o	\
                $(posix_dir)/proc-env.o $(posix_dir)/proc.o	\
                $(posix_dir)/io.o	$(posix_dir)/dir.o
POSIX_LD_FLAGS =
POSIX_INITIALIZERS = 	s48_init_posix_dir	s48_init_posix_user	\
			s48_init_posix_regexp	s48_init_posix_proc_env	\
			s48_init_posix_io	s48_init_posix_proc

# End of POSIX rules

# Socket rules

c/unix/socket.o: $(SCHEME48HS) c/fd-io.h c/event.h

SOCKET_OBJECTS = c/unix/socket.o
SOCKET_LD_FLAGS =
SOCKET_INITIALIZERS = 	s48_init_socket

# End of socket rules

# Dynamic linking rules

c/unix/dynlink.o: $(SCHEME48HS)

DYNLINK_OBJECTS = c/unix/dynlink.o
# configure adds -ldl or -mld to the regular libraries
DYNLINK_LD_FLAGS = 
DYNLINK_INITIALIZERS = 	s48_init_dynlink

# End of dynamic linking rules

# Sysexits (this is for the implementation of SRFI 22)

SYSEXITS_OBJECTS = c/unix/sysexits.o
SYSEXITS_LD_FLAGS =
SYSEXITS_INITIALIZERS = s48_init_sysexits

# Lookup rules (this is just for compatibility with old code)

c/unix/dynamo.o: $(SCHEME48HS)

LOOKUP_OBJECTS = c/unix/dynamo.o
LOOKUP_INITIALIZERS = 	s48_init_external_lookup

# End of lookup rules
# Native-code glue rules

ASM_OBJECTS = c/fake/glue.o
ASM_INITIALIZERS =

# Real definitions to be used when a. native code works and b. it is supported
# on the machine we're compiling on
#ASM_OBJECTS = c/glue.o c/asm-glue.o
#ASM_INITIALIZERS =	s48_init_asm_glue

# End of native-code glue rules

# Two-space copier objects

GC_TWOSPACE_OBJS = c/scheme48-twospace-heap.o

c/scheme48-twospace-heap.o: c/prescheme.h c/scheme48vm.h c/scheme48heap.h \
			c/scheme48vm-prelude.h c/c-mods.h \
			c/event.h c/io.h c/fd-io.h

# The BIBOP Garbage Collector
GC_BIBOP_OBJS =  c/scheme48-bibop-heap.o \
	c/bibop/page_alloc.o c/bibop/memory_map.o c/bibop/areas.o \
	c/bibop/generation_gc.o c/bibop/find_all.o c/bibop/check_heap.o \
	c/bibop/utils.o c/bibop/area_roots.o c/bibop/remset.o

bibop: $(GC_BIBOP_OBJS)

c/scheme48-bibop-heap.o: c/prescheme.h c/scheme48vm.h c/scheme48heap.h \
			c/scheme48vm-prelude.h c/scheme48write-barrier.h \
			c/bibop/bibop.h \
			c/c-mods.h c/event.h c/io.h c/fd-io.h

c/bibop/page_alloc.o: c/bibop/page_alloc.h c/bibop/page_constants.h            \
	c/bibop/memory.h
c/bibop/memory_map.o: c/bibop/memory_map.h c/bibop/utils.h                     \
	c/bibop/page_constants.h
c/bibop/areas.o: c/bibop/areas.h c/bibop/page_constants.h c/bibop/utils.h      \
	c/bibop/memory_map.h c/bibop/area_roots.h c/bibop/gc_config.h          \
	c/bibop/remset.h
c/bibop/generation_gc.o: c/bibop/generation_gc.h c/bibop/page_constants.h      \
	c/bibop/areas.h c/bibop/memory.h c/bibop/data.h c/bibop/utils.h        \
	c/bibop/memory_map.h c/bibop/check_heap.h c/bibop/area_roots.h         \
	c/bibop/measure.h c/bibop/measure.ci 				       \
	c/bibop/gc_config.h c/bibop/remset.h
c/bibop/find_all.o: c/bibop/find_all.h c/bibop/generation_gc.h c/bibop/areas.h \
	c/bibop/data.h c/bibop/memory.h
c/bibop/check_heap.o: c/bibop/check_heap.h c/scheme48.h c/bibop/generation_gc.h\
	c/bibop/utils.h c/bibop/data.h c/bibop/memory.h c/bibop/memory_map.h
c/bibop/area_roots.o: c/bibop/area_roots.h c/bibop/areas.h c/bibop/memory.h    \
	c/bibop/memory_map.h c/bibop/measure.h c/bibop/gc_config.h             \
	c/bibop/remset.h
c/bibop/remset.o: c/bibop/remset.h c/bibop/memory.h c/scheme48.h \
	c/bibop/utils.h c/bibop/data.h c/bibop/generation_gc.h \
	c/bibop/gc_config.h

# End of BIBOP GC rules


# SRFI rules

SRFI_OBJECTS = c/srfi-27.o
SRFI_INITIALIZERS = s48_init_srfi_27

# End of SRFI rules

# End of external rules
# --------------------

$(VM): c/main.o $(OBJS) $(GC_OBJS) $(UNIX_OBJS) $(LIBOBJS) $(EXTERNAL_OBJECTS)
	rm -f /tmp/s48_external_$$$$.c &&				\
	$(srcdir)/build/build-external-modules /tmp/s48_external_$$$$.c	\
		$(EXTERNAL_INITIALIZERS) &&				\
	$(CC) $(LDFLAGS) $(CFLAGS) -o $@ c/main.o 			\
		$(OBJS) $(GC_OBJS) $(UNIX_OBJS)				\
		/tmp/s48_external_$$$$.c				\
		$(LIBOBJS) $(LIBS)					\
		$(EXTERNAL_OBJECTS) $(EXTERNAL_LD_FLAGS) &&		\
	rm -f /tmp/s48_external_$$$$.c

$(LIBSCHEME48): $(OBJS) $(GC_OBJS) $(UNIX_OBJS) $(LIBOBJS) $(EXTERNAL_OBJECTS)
	rm -f $@;							\
	rm -f /tmp/s48_external_$$$$.c;					\
	$(srcdir)/build/build-external-modules /tmp/s48_external_$$$$.c	\
		$(EXTERNAL_INITIALIZERS) &&				\
	$(CC) -c $(CFLAGS) -o  /tmp/s48_external_$$$$.o			\
			/tmp/s48_external_$$$$.c &&			\
	ar cq $@ $(OBJS) $(GC_OBJS) $(UNIX_OBJS) $(LIBOBJS) $(EXTERNAL_OBJECTS)	\
		/tmp/s48_external_$$$$.o &&				\
	ranlib $@ &&					\
	rm -f /tmp/s48_external_$$$$.c

script-interpreter: c/script-interpreter.o
	$(CC) $(LDFLAGS) $(CFLAGS) -o $@ c/script-interpreter.o

c/main.o: c/main.c c/scheme48vm.h c/scheme48heap.h
	$(CC) -c $(CFLAGS) -o $@ \
		-DDEFAULT_IMAGE_NAME=\"$(LIB)/$(IMAGE)\" \
		$(CPPFLAGS) $(DEFS) $(srcdir)/c/main.c

c/scheme48vm.o: c/prescheme.h c/scheme48vm.h \
		c/scheme48write-barrier.h c/scheme48heap.h \
		c/scheme48image.h c/bignum.h c/event.h \
		c/io.h c/fd-io.h \
		c/scheme48vm-prelude.h c/c-mods.h

c/bignum.o: c/bignum.h c/bignumint.h $(SCHEME48HS)
c/extension.o: c/sysdep.h $(FAKEHS) $(SCHEME48HS) c/scheme48vm.h
c/free.o: c/sysdep.h
c/external.o: c/sysdep.h $(FAKEHS) $(SCHEME48HS) c/c-mods.h
c/unix/sysexits.o: c/sysdep.h $(FAKEHS) $(SCHEME48HS)
c/unix/event.o: c/sysdep.h $(FAKEHS) c/c-mods.h \
			c/scheme48vm.h c/scheme48heap.h \
			c/event.h c/fd-io.h \
			c/c-mods.h
c/unix/fd-io.o: c/sysdep.h $(FAKEHS) c/c-mods.h \
			c/scheme48vm.h c/scheme48heap.h \
			c/event.h c/fd-io.h 
c/unix/misc.o: c/sysdep.h $(FAKEHS)
c/unix/io.o: c/io.h
c/script-interpreter.o: c/sysdep.h $(FAKEHS) c/script-interpreter.c
	$(CC) -c $(CFLAGS) -o $@ \
		-DRUNNABLE=\"$(bindir)/$(RUNNABLE)\" \
		$(CPPFLAGS) $(DEFS) \
		-I ./c -I$(srcdir)/c \
		$(srcdir)/c/script-interpreter.c
c/fake/libdl1.o: c/fake/dlfcn.h
c/fake/libdl2.o: c/fake/dlfcn.h
c/fake/strerror.o: c/fake/strerror.h

# --------------------
# Make scheme48.image from initial.image and library .scm files.
#
# For bootstrap reasons, initial.image is *not* listed as a source,
# even though it really is.

$(IMAGE): $(VM) scheme/env/init-defpackage.scm scheme/more-interfaces.scm \
		scheme/link-packages.scm scheme/env-packages.scm \
		scheme/more-packages.scm \
		scheme/sort/interfaces.scm scheme/sort/packages.scm \
		scheme/cml/interfaces.scm scheme/cml/packages.scm \
		scheme/posix/packages.scm scheme/srfi/packages.scm \
		$(usual-files) build/initial.debug build/build-usual-image
	$(srcdir)/build/build-usual-image $(srcdir) "`(cd $(srcdir) && echo $$PWD)`/scheme" '$(IMAGE)' './$(VM)' \
		'$(INITIAL)'

### Fake targets:  all clean install man dist

install: enough dirs \
	 inst-script inst-vm inst-misc inst-man inst-inc inst-image \
	 inst-script-interpreters

inst-vm:
	$(INSTALL_PROGRAM) $(VM) $(LIB)

inst-image:
	rm -f '/tmp/$(IMAGE)' &&					\
	$(srcdir)/build/build-usual-image $(srcdir) '$(LIB)'            \
	         '/tmp/$(IMAGE)' './$(VM)' '$(INITIAL)' &&		\
	$(INSTALL_DATA) /tmp/$(IMAGE) $(LIB) &&				\
	rm /tmp/$(IMAGE)

inst-man:
	$(srcdir)/mkinstalldirs $(mandir)
	sed 's=LBIN=$(bindir)=g' $(srcdir)/doc/scheme48.man |	   \
		sed 's=LLIB=$(LIB)=g' |				   \
		sed 's=LS48=$(RUNNABLE)=g' >$(MANPAGE) &&	   \
	$(INSTALL_DATA) $(MANPAGE) $(mandir) &&			   \
	rm $(MANPAGE);						   \

inst-inc:
	$(INSTALL_DATA) $(srcdir)/c/scheme48.h $(incdir)
	$(INSTALL_DATA) $(srcdir)/c/scheme48write-barrier.h $(incdir)

inst-misc:
	for stub in env big sort opt misc link posix cml srfi; do	\
		for f in $(srcdir)/scheme/$$stub/*.scm; do		\
			$(INSTALL_DATA) $$f $(LIB)/$$stub || exit 1;	\
		done;							\
	done &&								\
	for f in $(srcdir)/scheme/rts/*num.scm 				\
		 $(srcdir)/scheme/rts/jar-defrecord.scm; do		\
		$(INSTALL_DATA) $$f $(LIB)/rts || exit 1;		\
	done

inst-script:
	script=$(bindir)/$(RUNNABLE) &&					\
	echo '#!/bin/sh'	>$$script &&				\
	echo			>>$$script &&				\
	echo 'lib=$(LIB)'	>>$$script &&				\
	echo 'exec $$lib/$(VM) -o $$lib/$(VM) -i $$lib/$(IMAGE) "$$@"'	\
				>>$$script &&				\
	chmod +x $$script

inst-script-interpreters:
	for dialect in r5rs srfi-7; do					\
		$(INSTALL_PROGRAM) script-interpreter $(bindir)/scheme-$$dialect; \
	done

# Script to run scheme48 in this directory.
go:
	echo '#!/bin/sh'	>$@ &&					\
	echo			>>$@ &&					\
	echo "lib=\"`pwd`\""	>>$@ &&					\
	echo 'exec "$$lib"/$(VM) -o "$$lib"/$(VM) -i "$$lib"/$(IMAGE) "$$@"'	\
				>>$@ &&					\
	chmod +x $@

dirs:
	for dir in $(libdir) $(bindir) $(incdir); do			 \
		$(srcdir)/mkinstalldirs $$dir || exit 1;	 		 \
	done
	$(srcdir)/mkinstalldirs $(LIB)
	for dir in rts env big sort opt misc link posix cml srfi; do	  \
		$(srcdir)/mkinstalldirs $(LIB)/$$dir || exit 1;	 	  \
	done

configure: configure.in
	autoheader && autoconf

clean:
	-rm -f $(VM) script-interpreter					\
		*.o c/unix/*.o c/posix/*.o c/*.o c/fake/*.o c/bibop/*.o\
		TAGS $(IMAGE)						\
		build/*.tmp $(MANPAGE) build/linker.image		\
		scheme/debug/*.image scheme/debug/*.debug config.cache	\
		scheme/vm/scheme48vm.c scheme/vm/scheme48heap.c		\
		go $(distname)

distclean: clean
	rm -f Makefile config.log config.status c/sysdep.h

check:	$(VM) $(IMAGE) scheme/debug/check.scm
	(								\
		echo ',batch';						\
		echo ',config ,load =scheme48/debug/test.scm';		\
		echo ',exec ,load =scheme48/debug/check.scm';		\
		echo ',exec (done)'					\
	) | ./$(VM) -i $(IMAGE)

# --------------------
# Rules from here on down are not essential for the basic installation
# procedure.

all: vm image $(LIBSCHEME48) script-interpreter go
libscheme48: $(LIBSCHEME48)
vm: $(VM)
image: $(INITIAL)
	$(MAKE) $(IMAGE)
test: check

tags:
	etags scheme/vm/interp/arch.scm scheme/rts/*.scm scheme/bcomp/*.scm \
	scheme/*.scm scheme/env/*.scm scheme/big/*.scm scheme/link/*.scm \
	scheme/opt/*.scm scheme/debug/*.scm scheme/misc/*.scm scheme/sort/*.scm \
	scheme/cml/*.scm

# --------------------
# Distribution...

# DISTFILES should include all sources.
DISTFILES = README COPYING.rtf COPYING INSTALL WINDOWS.txt		\
		configure acconfig.h configure.in Makefile.in 		\
		scheme48.dsp scheme48.dsw				\
		mkinstalldirs install-sh				\
		doc/*.ps doc/*.pdf doc/*.txt 				\
		doc/html/*.html doc/html/*.css doc/html/*.gif 		\
		doc/src/*.tex doc/src/*.sty doc/src/*.scm		\
		doc/scheme48.man					\
		emacs/README 						\
		build/*.scm build/*-version-number build/*.exec		\
		build/*.lisp build/build-usual-image build/filenames.make \
		build/initial.debug build/initial.image			\
		build/build-external-modules				\
		build/*.bat build/*.sh build/*.txt build/*.rc		\
		build/dummy build/*.wxs build/*.wxi			\
		build/*.bmp build/*.ico build/*.tif			\
		c/*.[ch] c/*/*.[ch] c/scheme48.h.in			\
		emacs/*.el gdbinit					\
		scheme/*.scm scheme/*/*.scm scheme/vm/*/*.scm		\
		ps-compiler/minor-version-number			\
		ps-compiler/doc/node.txt ps-compiler/doc/todo.txt	\
		ps-compiler/*.scm ps-compiler/*/*.scm			\
		ps-compiler/prescheme/primop/*.scm			\
		ps-compiler/prescheme/test/*.scm			\
		c/sysdep.h.in

distname = $(RUNNABLE)-1.`cat $(srcdir)/build/minor-version-number`

dist: build/initial.image c/scheme48.h
	distname=$(distname) &&						\
	distfile=$(distdir)/$$distname.tgz &&				\
	if [ -d $(distdir) ] &&						\
	   [ -w $$distfile -o -w $(distdir) ]; then			\
		cd $(srcdir) &&						\
		rm -f $$distname &&					\
		ln -s . $$distname &&					\
		files='' &&						\
		for i in $(DISTFILES); do				\
			if [ "$$i" != "c/sysdep.h" ]; then		\
				files="$$files $$distname/$$i";		\
			fi						\
		done &&							\
		tar -cf - $$files |					\
			gzip --best >$$distfile &&			\
		rm $$distname;						\
	else								\
		echo "Can't write $$distfile" >&2;			\
		exit 1;							\
	fi

# Increment the minor version number
inc:
	f=build/minor-version-number &&					\
	expr `cat $$f` + 1 >$$f.tmp &&					\
	mv $$f.tmp $$f &&						\
	cp $$f doc/src/version-number.tex &&				\
	echo '(define version-info "1.'`cat $$f`'")'			\
		>scheme/env/version-info.scm


# --------------------
# Generate build/filenames.make from *packages.scm
#
# This hack traces the module dependencies described in the
# various configuration files and converts them into dependency lists
# that "make" can use for its purposes.
#
# Since the distribution comes with a filenames.make, this rule
# shouldn't be invoked for simple installations.  But it will be used
# if you change any of the *-packages.scm files.
#
# You can actually run the forms in filenames.scm in any Scheme
# implementation that has syntax-rules and explicit-renaming low-level
# macros (e.g., most versions of Scheme 48 and Pseudoscheme).
# If there are errors running this script, and you need to debug,
# don't use the initial.image, use something that has a reasonable
# environment.
#
# If this fails and you don't feel like debugging or fixing the problem,
# try "touch filenames.make" and hope for the best.

PACKAGES=scheme/packages.scm scheme/rts-packages.scm scheme/alt-packages.scm \
	 scheme/comp-packages.scm scheme/initial-packages.scm \
	 scheme/link-packages.scm scheme/env-packages.scm \
	 scheme/sort/packages.scm scheme/more-packages.scm \
	 scheme/cml/packages.scm \
	 build/filenames.scm

$(srcdir)/build/filenames.make: $(PACKAGES)
# uncomment this if you activate the line below:
#	$(MAKE) $(VM) PACKAGES=
	cd $(srcdir) && \
	$(RUNNABLE) -a batch <build/filenames.scm
# or:	./$(VM) -i $(srcdir)/$(INITIAL) -a batch <build/filenames.scm


# --------------------
# Static linker
#
# The linker is capable of rebuilding an image from sources, even
# across an incompatible change in VM data representations.

# Bootstrap from Lucid Common Lisp: (last tested with
# Pseudoscheme 2.9 and Scheme 48 version 0.19)

PSEUDODIR = ../pseudo

link/linker-in-lucid: build/lucid-script.lisp $(linker-files) \
	    scheme/alt/pseudoscheme-features.scm \
	    scheme/alt/pseudoscheme-record.scm
	(echo \(defvar pseudoscheme-directory \"$(PSEUDODIR)/\"\); \
	 cat build/lucid-script.lisp; \
	 echo \(dump-linker\) \(lcl:quit\)) \
	| lisp

# --------------------
# Initial image
#
# The initial.image is built by the static linker.  The image contains
# Scheme, the byte-code compiler, and a minimal command processor, but
# no debugging environment to speak of.

$(INITIAL): $(CONFIG_FILES) build/initial.scm $(initial-files) $(linker-files)
	cd $(srcdir) &&							\
	($(START_LINKER);						\
		echo '(load-configuration "scheme/interfaces.scm")';	\
		echo '(load-configuration "scheme/vm/shared-interfaces.scm")'; \
		echo '(load-configuration "scheme/packages.scm")';	\
		echo '(flatload initial-structures)';			\
		echo '(load "build/initial.scm")';			\
		echo '(link-initial-system)'				\
	) | $(LINKER_RUNNABLE)

# --------------------
# Various small images for debugging low-level changes

LOAD_DEBUG = \
	 $(START_LINKER); \
	 echo \(load-configuration \"scheme/interfaces.scm\"\); \
	 echo \(load-configuration \"scheme/packages.scm\"\); \
	 echo \(load-configuration \"scheme/vm/shared-interfaces.scm\"\); \
	 echo \(flatload debug-structures\)

scheme/debug/tiny.image: scheme/debug/tiny-packages.scm \
		  scheme/debug/tiny.scm
	cd $(srcdir) && \
	($(START_LINKER); \
	 echo \(load-configuration \"scheme/debug/tiny-packages.scm\"\); \
	 echo \(link-simple-system \'\(scheme/debug tiny\) \'start tiny-system\)) \
	| $(LINKER_RUNNABLE)

scheme/debug/low-test.image: scheme/debug/low-test-packages.scm \
		  scheme/debug/low-test.scm
	cd $(srcdir) && \
	($(START_LINKER); \
	 echo \(load-configuration \"scheme/debug/low-test-packages.scm\"\); \
	 echo \(link-simple-system \'\(scheme/debug low-test\) \'start low-test-system\)) \
	| $(LINKER_RUNNABLE)

scheme/debug/little.image: $(CONFIG_FILES) scheme/debug-packages.scm
	cd $(srcdir) &&					\
	($(LOAD_DEBUG); echo \(link-little-system\))	\
	| $(LINKER_RUNNABLE)

scheme/debug/mini.image: $(CONFIG_FILES)
	cd $(srcdir) &&					\
	($(LOAD_DEBUG); echo \(link-mini-system\))	\
	| $(LINKER_RUNNABLE)

scheme/debug/medium.image: $(CONFIG_FILES)
	cd $(srcdir) &&						\
	($(LOAD_DEBUG); echo \(flatload compiler-structures\);	\
	 echo \(link-medium-system\)) \
	| $(LINKER_RUNNABLE)

# The following have not been updated for the new directory organization

c/smain.o: c/main.c
	$(CC) -c $(CPPFLAGS) $(DEFS) $(CFLAGS) -DSTATIC_AREAS -o $@ $(srcdir)/c/main.c

mini: mini-heap.o smain.o
	$(CC) $(LDFLAGS) $(CFLAGS) -o $@ c/smain.o mini-heap.o $(OBJS) $(LIBS)

mini-heap.o: mini-heap.c
	$(CC) -c $(CPPFLAGS) $(DEFS) $(CFLAGS) -o $@ $(srcdir)/mini-heap.c

mini-heap.c: scheme/debug/mini1.image
	(echo ,exec ,load misc/load-static.scm; \
	 echo \(do-it 150000 \"$(srcdir)/scheme/debug/mini1.image\" \"$@\"\)) \
	| $(RUNNABLE) -h 3000000 -a batch

scheme/debug/mini1.image: $(VM) scheme/debug/mini.image
	echo "(write-image \"scheme/debug/mini1.image\" \
			   (usual-resumer (lambda (args) \
					    (command-processor #f args))) \
			   \"foo\")" \
	| ./$(VM) -i scheme/debug/mini.image -a batch


# --------------------
# Generate unicode-info.scm and srfi-14-base-char-set.scm from UnicodeData.txt
# Get fresh UnicodeData.txt from http://www.unicode.org.

scheme/env/unicode-info.scm: build/UnicodeData.txt			\
	scheme/link/unicode-data.scm 					\
	scheme/env/unicode-category.scm					\
	scheme/big/compact-table.scm
	cd $(srcdir) &&							\
	(echo ',bench';							\
		echo ',batch';						\
		echo ',open finite-types destructuring define-record-types bitwise';		\
		echo ',open (subset srfi-13 (string-index string-prefix? string-suffix?))'; 	\
		echo ',open (subset srfi-1 (find)) srfi-23';					\
		echo ',load scheme/big/compact-table.scm scheme/env/unicode-category.scm';	\
		echo ',load scheme/link/unicode-data.scm';					\
		echo "(create-unicode-tables \"build/UnicodeData.txt\" \"scheme/env/unicode-info.scm\" \"scheme/srfi/srfi-14-base-char-sets.scm\")"		\
	) | $(RUNNABLE) -h 6000000

# --------------------
# Generate scheme48.h from VM sources

c/scheme48.h: c/scheme48.h.in scheme/vm/interp/arch.scm 		\
		scheme/vm/data/data.scm scheme/link/generate-c-header.scm
	cd $(srcdir) &&							\
	(echo ',bench';							\
		echo ',batch';						\
		echo ',load-package big-scheme';			\
		echo ',open big-scheme';				\
		echo ',load scheme/link/generate-c-header.scm';		\
		echo "(make-c-header-file \"$@\"			\
			  \"c/scheme48.h.in\"				\
			  \"scheme/vm/interp/arch.scm\"			\
			  \"scheme/vm/data/data.scm\"			\
			  \"scheme/rts/record.scm\")"			\
	) | $(RUNNABLE)

# An old version of the above for legacy code.

c/old-scheme48.h: scheme/vm/interp/arch.scm scheme/vm/data/data.scm \
	    scheme/link/generate-old-c-header.scm
	(echo ',bench';							\
		echo ',batch';						\
		echo ',load-package big-scheme';			\
		echo ',open big-scheme';				\
		echo ',load scheme/link/generate-old-c-header.scm';	\
		echo "(make-c-header-file \"$@\"			\
			  \"$(srcdir)/scheme/vm/interp/arch.scm\"	\
			  \"$(srcdir)/scheme/vm/data/data.scm\")"   	\
	) | $(RUNNABLE)

# Generate VM and GC from VM sources.
# Never called automatically.  Do not use unless you are sure you
# know what you are doing.
# Afterwards, you should probably make c/scheme48.h.

i-know-what-i-am-doing: compile-vm compile-twospace-gc compile-bibop-gc

# compiles VM without GC

compile-vm:
	cd $(srcdir)/ps-compiler &&					     \
	(echo ',batch';							     \
		echo ',config ,load ../scheme/prescheme/interface.scm';	     \
		echo ',config ,load ../scheme/prescheme/package-defs.scm';   \
		echo ',exec ,load load-ps-compiler.scm';		     \
		echo ',exec ,load compile-vm-no-gc.scm';		     \
		echo ',exit'						     \
	) | $(RUNNABLE) -h 8000000 &&					     \
		mv ../scheme/vm/scheme48vm.c ../c


# compiles the two-space copier GC

compile-twospace-gc:
	cd $(srcdir)/ps-compiler &&					     \
	(echo ',batch';							     \
		echo ',config ,load ../scheme/prescheme/interface.scm';	     \
		echo ',config ,load ../scheme/prescheme/package-defs.scm';   \
		echo ',exec ,load load-ps-compiler.scm';		     \
		echo ',exec ,load compile-twospace-gc.scm';		     \
		echo ',exit'						     \
	) | $(RUNNABLE) -h 8000000 &&					     \
		mv ../scheme/vm/scheme48-twospace-heap.c ../c

# compiles the BIBOP GC

compile-bibop-gc:
	cd $(srcdir)/ps-compiler &&					     \
	(echo ',batch';							     \
		echo ',config ,load ../scheme/prescheme/interface.scm';	     \
		echo ',config ,load ../scheme/prescheme/package-defs.scm';   \
		echo ',exec ,load load-ps-compiler.scm';		     \
		echo ',exec ,load compile-bibop-gc.scm';		     \
		echo ',exit'						     \
	) | $(RUNNABLE) -h 8000000 &&					     \
		mv ../scheme/vm/scheme48-bibop-heap.c ../c

