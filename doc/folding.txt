



FOLDING is a macro for writing loops that walk through sequences of values,
such as the elements of lists or vectors, while incrementally building up
one or more result values.  The macro expands into two functions, one of
which iterates through the elements of the given sequences, while the other
encapsulates the value-producing body of the FOLDING expression.

The iterating function is a generalization of the following, which walks
down a single list producing a single value.

  (define fold
    (lambda (proc list initial-state)
      (letrec ((loop (lambda (list state)
                       (if (null? list)
                           state
                           (loop (cdr list)
                                 (proc (car list) state))))))
        (loop list initial-state))))

FOLD walks down LIST using PROC to create a new STATE from the next element
of the list and the old STATE.  At the end of the list the current STATE is
returned.  For example, the following adds up the odd elements of a list of
numbers:

   (fold (lambda (n sum)
           (if (odd? n)
               (+ n sum)
               n))
	 list-of-numbers
         0)

The loop has been divided into two functions FOLD and (lambda (n sum) ...)
which correspond to the two functions created by the FOLDING macro.

Other versions of FOLD could have additional lists or other sequences.
FOLD-VECTOR-LIST might walk down a vector and a list in parallel:

  (define fold-vector-list
    (lambda (proc vector list)
      (letrec ((loop (lambda (i list state)
                       (if (or (= i (length vector))
                               (null? list))
                           state
                           (loop (+ i 1)
	                         (cdr list)
                                 (proc (vector-ref vector i)
                                       (car list)
                                       state))))))
        (loop list initial-state))))

Extra state variables can be added by having PROC and the FOLD function
itself return multiple values.  FOLD-2 has two state variables; both it and
its PROC argument return two values:

  (define fold-2
    (lambda (proc list initial-state0 initial-state1)
      (letrec ((loop (lambda (list state0 state1)
                       (if (null? list)
                           (values state0 state1)
                           (call-with-values
                             (lambda ()
                               (proc (car list) state0 state1))
                             (lambda (state0 state1)
                               (loop (cdr list) state0 state1)))))))
        (loop list initial-state0 initial-state1))))

The FOLDING macro constructs a FOLD-style function and applies it to the
lists or other sequences and the initial values of the state variables.
The basic syntax of FOLDING is:

  (folding ((sequence-type element-variable sequence-data ...)
            ...)
           ((state-variable initial-value)
            ...)
    body-expression
    [final-expression])

The <sequence-type>s are keywords (they are actually macros of a particular
form; it is easy to add additional types of sequences).  They include LIST*
which walks down the elements of a list and VECTOR* which does the same for
vectors.  For each iteration, each <element-variable> is bound to the next
element of the sequence.  The <sequence-data> gives the actual list or vector
or whatever.

<body-expression> must return as many values as their are state variables.
By special dispensation, if there are no state variables then <body-expression>
may return any number of values, all of which are ignored.

The meaning and use of the optional <final-expression> is described below.

FOLDING (without a <final-expression>) is equivalent to

  ((make-fold (sequence-type ...) (state-variable ...))
   (lambda (element-variable ... state-variable ...)
     body-expression)
   sequence-data ...
   initial-value ...)

where MAKE-FOLD expands into the appropriate FOLD function for the given
sequence types and with the correct number of state variables.

The net effect is to step the <element-variables>s in parallel through the
sequences.  The <state-variable>s have the corresponding <initial-value> for
the first iteration and have later values supplied by <body-expression>. 
If any sequence has reached its limit the value of the FOLDING expression is
the value of <final-expression>, if present, or the current values of
<state-variable>s, returned as multiple values.  If no sequence has reached
its limit, <body-expression> is evaluated and must return new values for the
<state-variable>s, as multiple values.

The above use of FOLD to add up the odd elements of a list could be written as

  (folding ((list* n list-of-numbers))
           ((sum 0))
    (if (odd? n)
        (+ n sum)
        n))

which in turn expands into

  ((make-fold (list*) (sum))
   (lambda (n sum)
     (if (odd? n)
         (+ n sum)
         n))
   list-of-numbers
   0)

and (make-fold (list*) (sum)) expands into the original definition of FOLD.

----------------
Sequence types

The predefined sequence types are:

  (list* <elt-var> <list>)
  (vector* <elt-var> <vector>)
  (string* <elt-var> <string>)
  (count* <elt-var> <start> [<end> [<step>]])
  (input* <elt-var> <input-port> <read-procedure>)
  (stream* <elt-var> <procedure> <initial-data>)

For lists, vectors, and strings the element variable is bound to the
successive elements of the list or vector, or the characters in the
string.

For `count*' element variable is bound to the elements of the 
sequence [<start>, <start> + <step>, <start> + 2<step>, ..., <end>),
inclusive of <start> and exclusive of <end>.  The default <step> is 1.
The sequence does not terminate if no <end> is given or if there
is no N > 0 such that <end> = <start> + N<step> (`=' is used to test
for termination).  In other words, (count* i 0 -1) doesn't end because
it begins past the final value and (count* i 0 1 2) doesn't because it
skips over the final value.

For `input*' the elements are the results of successive applications
of <read-procedure> to <input-port>.  The sequence ends when
<read-procedure> returns the end-of-file object.

For a stream, the <procedure> takes the current data value as an argument
and returns two values, the next value of the sequence and a new data
value.  If the new data is #F then the previous element was the last
one.  For example,

  (list* elt my-list)
  
is the same as

  (stream* elt list->stream my-list)

where list->stream is

  (lambda (list)
    (if (null? list)
        (values #f #f)
        (values (car list) (cdr list))))

----------------
Synchronous sequences

The FOLD functions used above terminate when any of the sequences reaches
its end.  To help detect bugs it is useful to have FOLD functions that
check to see if multiple sequences end at the same time.  For this purpose
there is second set of sequence types called synchronous sequences.  These
are identical to the ones listed above except that the resultant FOLD
function signals an error if one synchronous sequence reaches its end before
another.  If a loop is terminated by a synchronous sequence reaching its end,
then all other synchronous sequences must reach their end at that same
iteration.

Sequences are checked for termination in order, from left to right, and
if the loop is terminated by a non-synchronous sequence no further checking
is done.

They synchronous sequences are:

  (list% <elt-var> <list>)
  (vector% <elt-var> <vector>)
  (string% <elt-var> <string>)
  (count% <elt-var> <start> <end> [<step>])
  (input% <elt-var> <input-port> <read-procedure>)
  (stream% <elt-var> <procedure> <initial-data>)

Note that the sychronous COUNT% must have an <end>, unlike the nonsychronous
COUNT*.

----------------
State variables and final expressions

As mentioned above, the body of a FOLDING expression must return as many
values as there are state variables.  The following sorts a list of numbers
into the odd and even elements.

  (folding ((list* n number-list))
           ((odds '())
            (evens '()))
    (if (odd? n)
        (values (cons n odds) evens)
        (values odds (cons n evens))))

Quite often it is desirable to do some additional processing of the final
values of the state variables, which can be awkward.  If in the example
above the desired result were a single list with the odd elements before
the even ones, the code would be something like this:

  (call-with-values
    (lambda () 
      (folding ((list* n number-list))
               ((odds '())
                (evens '()))
        (if (odd? n)
            (values (cons n odds) evens)
            (values odds (cons n evens)))))
    append)

For this reason a FOLDING expression may contain a <final-expression> that is
evaluated after the loop has terminated and whose value(s) are returned by the
FOLDING expression.  The <final-expression> may refer to the state variables
but not to the sequence variables (because the sequences are completed).
The code can then be:

  (folding ((list* n number-list))
           ((odds '())
            (evens '()))
    (if (odd? n)
        (values (cons n odds) evens)
        (values odds (cons n evens)))
    (append odds evens))

The expansion of a FOLDING expression with a <final-expression> is

  ((make-fold (sequence-type ...) (state-variable ...))
   (lambda (element-variable ... state-variable ...)
     body-expression)
   (lambda (state-variable ...)
     final-expression)
   sequence-data ...
   initial-value ...)

with MAKE-FOLD expanding into a FOLD-like procedure that calls its second
argument on the final values of the state variables.

[This would seem to require that we have two different definitions of
 MAKE-FOLD.  In fact, the FOLDING macro uses the VALUES procedure as a
 default <final-expression>.  This gives the correct semantics and avoids
 the need for a second MAKE-FOLD.]

The <final-expression> is in tail-position within the FOLDING expression.

----------------

  (iterate loop-name
           ((sequence-type element-variable sequence-data ...)
            ...)
           ((state-variable initial-value)
            ...)
    body-expression
    [final-expression])

ITERATE is similar to FOLDING, except that the body must explicitly
begin the next iteration instead of falling through to it.  An
ITERATE expression includes a <loop-name> identifier that is bound
to the recursive loop procedure (much like named-LET).  This loop
procedure must be passed the new values of the state variable as
arguments.

The <final-expression> is evaluated when the end of one or more sequences
is reached.  If the <body-expression> does not call <loop-name> the
<final-expression> is not evaluated.

The <body-expression> and the <final-expression> are in tail-position within
the ITERATE.  The behavior of a non-tail-recursive call to <loop-name> is
unspecified.

[Any FOLDING expression may be rewritten as an equivalent ITERATE expression:

  (folding ((sequence-type element-variable sequence-data ...)
            ...)
           ((state-variable initial-value)
            ...)
    body-expression
    [final-expression])

   =>

  (iterate loop
           ((sequence-type element-variable sequence-data ...)
            ...)
           ((state-variable initial-value)
            ...)
    (call-with-values (lambda ()
                        body-expression)
                       loop)
    [final-expression])
]

----------------
Examples

Gathering the indexes of list elements that answer true to some
predicate:

(lambda (my-list predicate)
  (folding ((list* elt my-list)
	    (count* i 0))
           ((hits '()))
    (if (predicate elt)
        (cons i hits)
	hits)
    reverse))

Looking for the index of an element of a list.

(lambda (my-list predicate)
  (iterate loop
           ((list* elt my-list)
            (count* i 0))
           ()				; no state
    (if (predicate elt)
	i
	(loop))))

Reading one line.

(define (read-line port)
  (iterate loop
           ((input* c port read-char))
           ((chars '()))
    (if (char=? c #\newline)
	(list->string (reverse chars))
	(loop (cons c chars)))
    (if (null? chars)
	(eof-object)
	(list->string (reverse chars)))))	; no newline at end of file

Counting the lines in a file.  We can't use NATURAL* because we
need the value of the count after the loop has finished.

(define (line-count name)
  (call-with-input-file name
    (lambda (in)
      (folding ((input* l in read-line))
	       ((i 0))
	(+ i 1)))))

----------------
Implementation

The whole thing is implemented using SYNTAX-RULES (although I had to
fix a bug in S48's implementation to get it to work).  The sequence
types are object-oriented macros similar to enumerations.  They
aren't hard to write.  A macro-defining macro for doing so would
make them even simpler, but I have no confidence in macro-defining
macros written using SYNTAX-RULES.

A non-synchronous sequence macro needs to supply three values:
#F to indicate that it isn't synchronous, a list of state variables
and their initializers, and the code for one iteration.  The first
two methods are CPS'ed: they take another macro and argument to
which to pass their result.  Having a macro to define sequences 
could hide the CPS'ing.  The SYNCHRONIZED? method gets no additional
arguments.  The state-var method is passed a list of names which
will be bound to the arguments to the sequence.

The final method, for the step, is passed the list of names bound to
the arguments and the list of state variables.  In addition there is
a variable to be bound to the next element of the sequence, the
body expression for the loop, and an expression for terminating the
loop.

The definition of LIST* is

(define-syntax list*
  (syntax-rules (synchronized? state-vars step)
    ((list* synchronized? (next more))
     (next #f more))
    ((list* state-vars (start-list) (next more))
     (next ((list-var start-list)) more))
    ((list* step (start-list) (list-var) value-var loop-body final-exp)
     (if (null? list-var)
         final-exp
         (let ((value-var (car list-var))
               (list-var (cdr list-var)))
           loop-body)))))

Synchronized sequences are the same, except that they need to
provide a termination test to be used when some other synchronized
method terminates the loop.

(define-syntax list%
  (syntax-rules (sync done)
    ((list% sync (next more))
     (next #t more))
    ((list% done (start-list) (list-var))
     (null? list-var))
    ((list% stuff ...)
     (list* stuff ...))))

The expansion of 

  (folding ((list* x '(1 2 3)))
           ((r '()))
    (cons x r))

is

  (let ((final (lambda (r) (values r)))
	(list '(1 2 3))
	(r '()))
    (let loop ((list list) (r r))
      (if (null? list)
	  (final r)
	  (let ((x (car list))
		(list (cdr list)))
	    (let ((continue (lambda (r)
			      (loop list r))))
	      (continue (cons x r)))))))

There is a little beta reduction for the compiler to do.  The macro
expander could substitute the value of CONTINUE when there is no
explicit proceed variable, as in this case, but not in general.
