<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- HTML file produced from file: manual.tex --
 -- using Hyperlatex v 2.3.1 (c) Otfried Cheong--
 -- on Emacs 20.4.1, Wed May 30 12:23:58 2001 -->
<HEAD>
<TITLE>Scheme 48 Manual -- Process primitives</TITLE>

</HEAD><BODY BGCOLOR="#ffffff">
<EM>Scheme 48 Manual</EM> | <A HREF="s48manual.html#top_node">Contents</A> | In Chapter: <A HREF="s48manual_64.html">Access to POSIX</A><BR>Previous: <A HREF="s48manual_64.html">Access to POSIX</A> | Next: <A HREF="s48manual_66.html">Signals</A>
<H2>Process primitives</H2>
<P>The procedures described in this section control the creation of processes
 and the execution of programs.
They are in the structures <CODE>posix-process</CODE> and <CODE>posix</CODE>.
<H3><A NAME="processes">Process creation and termination</A></H3>

<UL><LI><CODE>(fork<I></I>)&nbsp;-&gt;&nbsp;<I>process-id&nbsp;or&nbsp;<TT>&nbsp;#f</TT></I></CODE><A NAME="2">&nbsp;</A>
<LI><CODE>(fork-and-forget<I>&nbsp;thunk</I>)</CODE><A NAME="3">&nbsp;</A>
</UL>
<CODE>Fork</CODE> creates a new child process and returns the child's process-id in
 the parent and <CODE>#f</CODE> in the child.
<CODE>Fork-and-forget</CODE> calls <CODE><I>thunk</I></CODE> in a new process; no process-id
 is returned.
<CODE>Fork-and-forget</CODE> uses an intermediate process to avoid creating
 a zombie process.
<UL><LI><CODE>(process-id?<I>&nbsp;x</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="4">&nbsp;</A>
<LI><CODE>(process-id=?<I>&nbsp;process-id0&nbsp;process-id1</I>)&nbsp;-&gt;&nbsp;<I>boolean</I></CODE><A NAME="5">&nbsp;</A>
<LI><CODE>(process-id-&gt;integer<I>&nbsp;process-id</I>)&nbsp;-&gt;&nbsp;<I>integer</I></CODE><A NAME="6">&nbsp;</A>
<LI><CODE>(integer-&gt;process-id<I>&nbsp;integer</I>)&nbsp;-&gt;&nbsp;<I>process-id</I></CODE><A NAME="7">&nbsp;</A>
</UL>
<CODE>Process-id?</CODE> is a predicate for process-ids,
<CODE>process-id=?</CODE> compares two to see if they are the same,
 and <CODE>process-id-uid</CODE> returns the actual Unix id.
<CODE>Process-id-&gt;integer</CODE> and <CODE>integer-&gt;process-id</CODE>
 convert process ids to and from integers.
<UL><LI><CODE>(process-id-exit-status<I>&nbsp;process-id</I>)&nbsp;-&gt;&nbsp;<I>integer&nbsp;or&nbsp;<TT>&nbsp;#f</TT></I></CODE><A NAME="8">&nbsp;</A>
<LI><CODE>(process-id-terminating-signal<I>&nbsp;process-id</I>)&nbsp;-&gt;&nbsp;<I>signal&nbsp;or&nbsp;<TT>&nbsp;#f</TT></I></CODE><A NAME="9">&nbsp;</A>
<LI><CODE>(wait-for-child-process<I>&nbsp;process-id</I>)</CODE><A NAME="10">&nbsp;</A>
</UL>
If a process terminates normally
 <CODE>process-id-exit-status</CODE> will return its exit status.
If the process is still running or was terminated by a signal then
 <CODE>process-id-exit-status</CODE> will return <CODE>#f</CODE>.
Similarly, if a child process was terminated by a signal
 <CODE>process-id-terminating-signal</CODE> will return that signal and
 will return <CODE>#f</CODE> if the process is still running or terminated
 normally.
<CODE>Wait-for-child-process</CODE> blocks until the child process terminates.
Scheme&nbsp;48 may reap child processes before the user requests their
 exit status, but it does not always do so.
<UL><LI><CODE>(exit<I>&nbsp;status</I>)</CODE><A NAME="11">&nbsp;</A>
</UL>
Terminates the current process with the integer <CODE><I>status</I></CODE>
 as its exit status.
<H3><A NAME="12"><TT>Exec</TT></A></H3>
<UL><LI><CODE>(exec<I>&nbsp;program-name&nbsp;arg0&nbsp;...</I>)</CODE><A NAME="13">&nbsp;</A>
<LI><CODE>(exec-with-environment<I>&nbsp;program-name&nbsp;env&nbsp;arg0&nbsp;...</I>)</CODE><A NAME="14">&nbsp;</A>
<LI><CODE>(exec-file<I>&nbsp;filename&nbsp;arg0&nbsp;...</I>)</CODE><A NAME="15">&nbsp;</A>
<LI><CODE>(exec-file-with-environment<I>&nbsp;filename&nbsp;env&nbsp;arg0&nbsp;...</I>)</CODE><A NAME="16">&nbsp;</A>
<LI><CODE>(exec-with-alias<I>&nbsp;name&nbsp;lookup?&nbsp;maybe-env&nbsp;arguments</I>)</CODE><A NAME="17">&nbsp;</A>
</UL>
All of these replace the current program with a new one.
They differ in how the new program is found, what its environment is,
 and what arguments it is passed.
<CODE>Exec</CODE> and <CODE>exec-with-environment</CODE>
 look up the new program in the search path,
 while <CODE>exec-file</CODE> and <CODE>exec-file-with-environment</CODE>
 execute a particular file.
The environment is either inherited from the current process
 (<CODE>exec</CODE> and <CODE>exec-file</CODE>) or given as an argument
 (<CODE>...-with-environment</CODE>).
<CODE><I>Program-name</I></CODE> and <CODE><I>filename</I></CODE> and any <CODE><I>arg<I><sub>i</sub></I></I></CODE> should be strings.
 <CODE><I>Env</I></CODE> should be a list of strings of the form
 <CODE>"<CODE><I>name</I></CODE>=<CODE><I>value</I></CODE>"</CODE>.
The first four procedures add their first argument, <CODE><I>program-name</I></CODE> or
 <CODE><I>filename</I></CODE>, before the <CODE><I>arg0&nbsp;...</I></CODE> arguments.
<P><CODE>Exec-with-alias</CODE> is an omnibus procedure that subsumes the other
 four.
<CODE><I>Name</I></CODE> is looked up in the search path if <CODE><I>lookup?</I></CODE> is true
 and is used as a filename otherwise.
<CODE><I>Maybe-env</I></CODE> is either a list of strings for the environment of the
 new program or <CODE>#f</CODE> in which case the new program inherits its
 environment from the current one.
<CODE><I>Arguments</I></CODE> should be a list of strings; unlike with the other four
 procedures, <CODE><I>name</I></CODE> is not added to this list (hence <CODE>-with-alias</CODE>).
<P>
  
Previous: <A HREF="s48manual_64.html">Access to POSIX</A> | Next: <A HREF="s48manual_66.html">Signals</A></BODY></HTML>
